#Using make files

Using parameter-weaver from a make file is quite straightforward.  This
section cover an example for C as well as for Fortran.

##C example

For simplicity, it will be assumed that the entire source code for the C
program `example` is in a file `example.c`.  Additionally it is assumed
that the code generated by parameter-weaver is stored in files with the
standard names, and the parameter-weaver definitions are in
`example_params.txt`, so we have

  * `example.c`
  * `example_params.txt`
  * `cl_params.h`
  * `cl_params.c`
  * `cl_params_aux.h`
  * `cl_params_aux.c`

To link the application `example`, the object files `example.o`,
`cl_params.o` and `cl_params_aux.o` will be required, hence:
```
OBJS = example.o cl_params.o cl_params_aux.o

example: $(OBJS)
	$(CC) $(CFLAGS) $(CPPFLAGS) -o $@ $(OBJS) $(LDFLAGS) $(LIBS)
```
The object file `example.o` obviously depends on the source code in
`example.c`, but also on the definition of the `struct` in `cl_params.h`,
so:
```
example.o:_cl_params.h example.c
	$(CC) $(CFLAGS) $(CPPFLAGS) -o $@ example.c
```
The two object files for parameter-weaver generated code simply depend
on the source code, but need rules since they don't exist when make is
run for the first time:
```
cl_params.o: cl_params.c
	$(CC) $(CFLAGS) $(CPPFLAGS) -o $@ $<

cl_params_aux.o: cl_params_aux.c
	$(CC) $(CFLAGS) $(CPPFLAGS) -o $@ $<
```
parameter-weaver should be triggered to generate the code, so:
```
cl_params.h: 
	weave -l C -d $<
```

The rule for `clean` should remove all parameter-weaver artifacts, so:
```
clean:
	rm -f *.o example cl_params.[ch] cl_params_aux.[ch]
```

When distirubting code, include the generated files, and in the
corresponding make file, do not remove the parameter artifacts in the
`clean` rule, and omit the rule for `cl_params.h`.

##Fortran example

For simplicity, it will be assumed that the entire source code for the C
program `example` is in a file `example.f90`.  Additionally it is assumed
that the code generated by parameter-weaver is stored in files with the
standard names, and the parameter-weaver definitions are in
`example_params.txt`, so we have

  * `example.f90`
  * `example_params.txt`
  * `cl_params.f90`

To link the application `example`, the object files `example.o` and
`cl_params.o` will be required, hence:
```
OBJS = example.o cl_params.o

example: $(OBJS)
	$(F90) $(FFLAGS) -o $@ $(OBJS) $(LDFLAGS) $(LIBS)
```
The object file `example.o` obviously depends on the source code in
`example.f90`, but also on the definition of the user defined type in
`cl_params.f90`, so:
```
example.o:_cl_params.f90 example.f90
	$(F90) $(FFLAGS) -o $@ example.f90
```
The object file for parameter-weaver generated code simply depends
on the source code, but need a rule since it doesn't exist when make is
run for the first time:
```
cl_params.o: cl_params.f90
	$(F90) $(FFLAGS) -o $@ $<

```
parameter-weaver should be triggered to generate the code, so:
```
cl_params.f90: 
	weave -l Fortran -d $<
```

The rule for `clean` should remove the parameter-weaver artifact, so:
```
clean:
	rm -f *.o *.mod example cl_params.f90
```

When distirubting code, include the generated file, and in the
corresponding make file, do not remove the parameter artifact in the
`clean` rule, and omit the rule for `cl_params.f90`.
