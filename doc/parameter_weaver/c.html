<html>

<head>
<title>C/C++ documentation</title>
</head>

<body>
<h1>C/C++ documentation</h1>

<h2>Data types</h2>

<p> For C/C++, ParameterWeaver supports the following data types:
<ol>
  <li> <tt>int</tt> </li>
  <li> <tt>long</tt> </li>
  <li> <tt>float</tt> </li>
  <li> <tt>double</tt> </li>
  <li> <tt>bool</tt> </li>
  <li> <tt>char *</tt> </li>
</ol>
</p>

<h2>Example C program</h2>
<p> Suppose we want to pass command line parameters to the following C program:
<pre>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
    FILE *fp;
    int i;
    if (strlen(out) &gt; 0) {
        fp = fopen(out, "w");
    } else {
        fp = stdout;
    }
    if (verbose) {
        fprintf(fp, "# n = %d\n", n);
        fprintf(fp, "# alpha = %.16f\n", alpha);
        fprintf(fp, "# out = '%s'\n", out);
        fprintf(fp, "# verbose = %s\n", verbose);
    }
    for (i = 0; i &lt; n; i++) {
        fprintf(fp, "%d\t%f\n", i, i*alpha);
    }
    if (fp != stdout) {
        fclose(fp);
    }
    return EXIT_SUCCESS;
}
</pre>
We would like to set the number of iterations <tt>n</tt>, the factor <tt>alpha</tt>, the name of the file to write the output to <tt>out</tt> and the verbosity <tt>verbose</tt> at runtime, i.e., without modifying the source code of this program. </p>
<p> Moreover, the code to print the values of the variables is error prone, if we later add or remove a parameter, this part of the code has to be updated as well. </p>
<p> Defining the command line parameters in a parameter definition file to automatlically generate the necessary code simplifies matters considerably. </p>

<h2>Example parameter definition file</h2>
The following file defines four command line parameters named <tt>n</tt>, <tt>alpha</tt>,  <tt>out</tt> and <tt>verbose</tt>.  They are to be interpreted as <tt>int</tt>, <tt>double</tt>, <tt>char</tt> pointer and <tt>bool</tt> respectively, and if no values are passed via the command line, they will have the default values <tt>10</tt>, <tt>0.19</tt>, <tt>output.txt</tt> and false respectively.  Note that a string default value is quoted.  In this case, the columns in the file are separated by tab characters.  The following is the contents of the parameter definition file <tt>param_defs.txt</tt>:
<pre>
int	n	10
double	alpha	0.19
char *	out	'output.txt'
bool	verbose	false
</pre>
This parameter definition file can be created in a text editor such as the one used to write C program, or from a Microsoft Excel worksheet by saving the latter as a CSV file. </p>
<p> As mentioned above, boolean values are also supported, however, the semantics is slightly different from other data types.  The default value of a logical variable is always false, regardless of what is specified in the parameter definition file.  As opposed to parameters of other types, a logical parameter acts like a flag, i.e., it is a command line options that doesn't take a value.  Its absence is interpreted as false, its presence as true.  Also note that using a parameter of type <tt>bool</tt> implies that the program will have to be complied as C99, rather than C89.  All modern cmopiler fully support C99, so that should not be an issue.  However, if your program needs to adhere strictly to the C89 standard, simply use a parameter of type <tt>int</tt> instead, with <tt>0</tt> interpreted as false, all other values as true.  In that case, the option takes a value on the command line. </p>

<h2>Generating code</h2>
<p> Generating the code fragments is now very easy.  If appropriate, load the module (VIC3):
<pre>
$ module load parameterweaver
</pre>
Next, we generate the code based on the parameter definition file:
<pre>
$ weave -l C -d param_defs.txt
</pre>
<p> A number of type declarations and functions are generated, the declarations in the header file <tt>cl_params.h</tt>, the defintions in the source file <tt>cl_params.c</tt>.
<ol>
  <li> data structure: a type <tt>Params</tt> is defined as a <tt>typedef</tt> of a <tt>struct</tt> with the parameters as fields, e.g.,
<pre>
typedef struct {
    int n;
    double alpha;
    char *out;
    bool verbose;
} Params;
</pre> </li>
  <li> Initialization function: the default values of the command line parameters are assigned to the fields of the <tt>Params</tt> variable, the address of which is passed to the function</li>
  <li> Parsing: the options passed to the program via the command line are assigned to the appropriate fields of the <tt>Params</tt> variable.  Moreover, the <tt>argv</tt> array containing the remaining command line arguments, the <tt>argc</tt> variable is set apprppriately. </li>
  <li> Dumper: a function is defined that takes three arguments: a file pointer, a prefix and the address of a <tt>Params</tt> variable.  This function writes the values of the command line parameters to the file pointer, each on a separate line, preceeded by the specified prefix. </li>
  <li> Finalizer: a function that deallocates memory allocated in the initialization or the parsing functions to avoid memory leaks. </li>
</ol>
</p>

<h2>Using the code fragments</h2>
<p> The declarations are simply included using preprocessor directives:
<pre>
  #include "cl_parser.r"
</pre>
A variable to hold the parameters has to be defined and its values initialized:
<pre>
  Params params;
  initCL(&amp;params);
</pre>
Next, the command line parameters are parsed and their values assigned:
<pre>
  parseCL(&amp;params, &amp;argc, &amp;argv);
</pre>
The dumper can be called whenever the user likes, e.g.,
<pre>
  dumpCL(stdout, "", &amp;params);
</pre>
The code for the program is thus modified as follows:
<pre>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "cl_params.h"

int main(int argc, char *argv[]) {
    FILE *fp;
    int i;
    Params params;
    initCL(&amp;params);
    parseCL(&amp;params, &amp;argc, &amp;argv);
    if (strlen(params.out) &gt; 0) {
        fp = fopen(params.out, "w");
    } else {
        fp = stdout;
    }
    if (params.verbose) {
        dumpCL(fp, "# ", &amp;params);
    }
    for (i = 0; i &lt; params.n; i++) {
        fprintf(fp, "%d\t%f\n", i, i*params.alpha);
    }
    if (fp != stdout) {
        fclose(fp);
    }
    finalizeCL(&amp;params);
    return EXIT_SUCCESS;
}
</pre>
Note that in this example, additional command line parameters are simply ignored.  As mentioned before, they are available in the array <tt>argv</tt>, <tt>argv[0]</tt> will hold the programs name, subsequent elements up to <tt>argc - 1</tt> contain the remaining command line parameters. </p>

<h2>Using a configuration file</h2>
ParameterWeaver generates a function from the same parameter definition file to parse a configuration file, in addition to command line parameters.  The format of the configuration file, e.g., <tt>config-03.txt' is very straightforward, as the example below illustrates.
<pre>
alpha = 0.19
# comments can be added, as can blank lines
out = 'output-03.txt'

verbose = true
</pre>
Comment lines start with a '#', and are ignored, as are blank lines.</p>
<p>Parsing such a configuration file is now as simple as a single function call:
<pre>
    ...
    parseFileCL(&amp;params, 'config-03.txt');
    ...
</pre>
Note that both command line parameters and configuration files can be used in the same program, and that their priority is simply determined by the order of calling <tt>parseCL</tt> and <tt>fileParseCL</tt>. </p>

</body>

</html>
